---
output:
  md_document:
    variant: markdown_github
---

`r badger::badge_github_actions("jaytimm/pubmedtk")`

# pubmedtk

The package provides a single interface for accessing a range of NLM/PubMed databases, including [PubMed](https://pubmed.ncbi.nlm.nih.gov/) abstract records, [iCite](https://icite.od.nih.gov/) bibliometric data, [PubTator](https://www.ncbi.nlm.nih.gov/research/pubtator/) named entity annotations, and full-text entries from [PubMed Central](https://www.ncbi.nlm.nih.gov/pmc/) (PMC).  This unified interface simplifies the data retrieval process, allowing users to interact with multiple PubMed services/APIs/output formats through a single R function. 

The package also includes MeSH ontology resources as simple data frames, including Descriptor Terms, Descriptor Tree Structures, Supplementary Concept Terms, and Pharmacological Actions; it also includes descriptor-level word embeddings [(Noh & Kavuluru 2021)](https://www.sciencedirect.com/science/article/pii/S1532046421001969). Via the [mesh-resources](https://github.com/jaytimm/mesh-resources) library.



## Installation

You can download the development version from GitHub with:

```{r message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
```


```{r eval=FALSE}
devtools::install_github("jaytimm/pubmedtk")
```


## Usage

## PubMed search

The package has two basic functions: `search_pubmed` and `get_records`. The former fetches PMIDs from the PubMed API based on user search; the latter scrapes PMID records from a user-specified PubMed endpoint -- `pubmed_abstracts`, `pubmed_affiliations`, `pubtations`, `icites`, or `pmc_fulltext`.

Search syntax is the same as that implemented in standard [PubMed search](https://pubmed.ncbi.nlm.nih.gov/advanced/). 


```{r eval=FALSE, include=FALSE}
ppm <- PubmedMTK::pmtk_search_pubmed('immunity')
```




```{r}
yrs <- 2010:2023

pubmed_query <- paste0('("political ideology"[TiAb]) AND (',
                       yrs, ':', yrs,
                       '[pdat])')

pmids <- lapply(pubmed_query, pubmedtk::search_pubmed)
pmids <- pmids |> unlist() |> unique() |> sort() #|> sample(10000)
```


```{r eval=FALSE, include=FALSE}
pubmed_query <- paste0('("immunity"[MeSH Terms]) AND (',
                       yrs, ':', yrs,
                       '[pdat])')

# pubmed_query <- paste0('("medical marijuana"[MeSH Terms]) AND (', 
#                        yrs, ':', yrs,  
#                        '[pdat])')


# x <- paste0('"marijuana"[TiAb]')
# 
# pubmed_query <- '"immunity"[MeSH Terms]'
# 
# pmids <- x |> pubmedtk::search_pubmed()


#########
```





```{r eval=FALSE, include=FALSE}
batch_size <- 199
batches <- split(pmids, ceiling(seq_along(pmids) / batch_size))
records <- pubmedtk:::.fetch_records(x = batches[[1]])
x <- records[[1]]
vv <- list(lapply(parsed_records, '[[', 2))
```



## Get record-level data

```{r}
recs_pubmed <- pmids |> 
  pubmedtk::get_records(endpoint = 'pubmed_abstracts', 
                        cores = 5, 
                        sleep = 1) 

recs_affs <- pmids |> 
  pubmedtk::get_records(endpoint = 'pubmed_affiliations', 
                        cores = 3, 
                        sleep = 0.5)

recs_icites <- pmids |> 
  pubmedtk::get_records(endpoint = 'icites',
                        cores = 1, 
                        sleep = 0.25)

recs_pubtations <- pmids |> 
  pubmedtk::get_records(endpoint = 'pubtations')
```


> When the endpoint is PMC, the `get_records() function takes a vector of filepaths (from the PMC Open Access list) instead of PMIDs.

```{r}
pmclist <- pubmedtk::data_pmc_list(force_install = F)
pmc_pmids <- pmclist[PMID %in% pmids]

recs_pmc <- pmc_pmids$fpath |> 
  pubmedtk::get_records(endpoint = 'pmc_fulltext', cores = 5)
```
```{r eval=FALSE, include=FALSE}
recs_pubtations <- pmids[1:50] |> get_pmc()
```





### `pubmed_abstracts`

```{r}
pmid_eg <- 24781819
```


```{r}
recs_pubmed |> 
  select(-annotations) |>
  filter(pmid == pmid_eg) |>
  mutate(abstract = stringr::str_sub(abstract, 1, 150) |>
                     paste0("...")) |>
  knitr::kable()
```


```{r eval=FALSE, include=FALSE}
x1 <- recs_pubmed |> filter(pmid %in% pmc_pmids$PMID) 
x2 <- recs_pubtations |> filter(pmid %in% pmc_pmids$PMID) 
```


```{r}
recs_pubmed |> 
  #select(-annotations) |>
  filter(pmid == pmid_eg) |>
  pull(annotations) |>
  bind_cols() |>
  knitr::kable()
```



### `pubmed_affiliates`

```{r}
recs_affs |> 
  filter(pmid == pmid_eg) |>
  knitr::kable()
```


### `icites`

```{r}
citations <- recs_icites |> 
  filter(pmid == pmid_eg)

c0 <- citations |> select(-citation_net) 
setNames(data.frame(t(c0[,-1])), c0[,1]) |> knitr::kable()
```


```{r}
citations$citation_net[[1]] |> head() |> knitr::kable()
```




### `pubtations`

```{r}
recs_pubtations |> 
  filter(pmid == pmid_eg) |>
  knitr::kable()
```


### `pmc_fulltext`

```{r}
samp <- recs_pmc |> filter(pmid == pmid_eg)

lapply(samp$text, function(x){strwrap(x, width = 60)[1:3]})
```

